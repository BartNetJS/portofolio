<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memristor Learning Simulator</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@300;500;700&display=swap');

        :root {
            --bg-color: #0a0e17;
            --panel-bg: #121a2e;
            --text-main: #e0e6ed;
            --accent-cyan: #00f5ff;
            --accent-purple: #9d00ff;
            --accent-green: #00ff88;
            --accent-magenta: #ff00aa;
            --accent-orange: #ffaa00;
            --border-color: #2a3b55;
            --ion-color: #ffaa00;
            --undoped-color: #2a1a4a;
            --doped-color: #00f5ff; /* Opacity will be handled in JS */
        }

        body {
            font-family: 'Rajdhani', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            box-sizing: border-box;
        }

        h1, h2, h3, h4 {
            font-family: 'Orbitron', sans-serif;
            margin: 0 0 10px 0;
            color: var(--accent-cyan);
            text-transform: uppercase;
        }

        .container {
            display: grid;
            grid-template-columns: 300px 1fr;
            grid-template-rows: auto 1fr auto;
            gap: 20px;
            width: 100%;
            max-width: 1400px;
            height: 100%;
            border: 1px solid var(--border-color);
            background: rgba(18, 26, 46, 0.5);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.1);
        }

        /* Header */
        header {
            grid-column: 1 / -1;
            border-bottom: 2px solid var(--accent-cyan);
            padding-bottom: 10px;
            text-align: center;
            text-shadow: 0 0 10px var(--accent-cyan);
        }

        /* Sidebar: Controls & Data */
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
        }

        .panel {
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            padding: 15px;
            border-radius: 5px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            color: var(--accent-cyan);
            font-size: 0.9em;
        }

        select, input, button {
            width: 100%;
            padding: 8px;
            background: #05080e;
            border: 1px solid var(--border-color);
            color: var(--text-main);
            font-family: 'Orbitron', sans-serif;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        button:hover {
            border-color: var(--accent-cyan);
            box-shadow: 0 0 10px rgba(0, 245, 255, 0.2);
        }
        
        button.primary {
            background: rgba(0, 245, 255, 0.1);
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }

        button.mode-toggle {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .mode-active {
            background: var(--accent-cyan) !important;
            color: #000 !important;
        }

        .training-data-list {
            max-height: 200px;
            overflow-y: auto;
            font-size: 0.9em;
        }

        .data-row {
            display: flex;
            justify-content: space-between;
            padding: 5px;
            border-bottom: 1px solid #1e2a45;
        }
        
        .data-row.active {
            background: rgba(0, 255, 136, 0.1);
            border-left: 3px solid var(--accent-green);
        }

        /* Main View */
        .main-view {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .visualization-area {
            flex: 1;
            background: #000;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            position: relative;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #memristor-svg {
            width: 100%;
            height: 100%;
        }

        .stats-bar {
            display: flex;
            justify-content: space-around;
            background: var(--panel-bg);
            padding: 10px;
            border: 1px solid var(--border-color);
            font-family: 'Orbitron', monospace;
            font-size: 1.2em;
        }
        
        .stat-item span {
            color: var(--accent-orange);
        }

        .computation-view {
            height: 150px;
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            position: relative;
        }
        
        .math-equation {
            font-size: 2em;
            font-family: 'Orbitron', sans-serif;
            display: flex;
            gap: 15px;
            align-items: center;
        }
        
        .math-var {
            color: var(--accent-green);
        }

        /* Logs */
        .log-panel {
            grid-column: 1 / -1;
            height: 150px;
            background: #000;
            border: 1px solid var(--border-color);
            padding: 10px;
            font-family: 'Consolas', monospace;
            font-size: 0.85em;
            overflow-y: auto;
            color: #888;
        }
        
        .log-entry { margin-bottom: 2px; }
        .log-info { color: #888; }
        .log-success { color: var(--accent-green); }
        .log-warn { color: var(--accent-orange); }

        /* SVG Styles */
        .electrode { fill: #555; stroke: #888; stroke-width: 2; }
        .electrode-text { font-family: 'Orbitron', sans-serif; font-size: 14px; fill: #aaa; text-anchor: middle; }
        .doped-region { fill: var(--doped-color); opacity: 0.3; }
        .undoped-region { fill: var(--undoped-color); }
        .ion { fill: var(--ion-color); filter: drop-shadow(0 0 2px var(--ion-color)); }
        .current-particle { fill: var(--accent-green); filter: drop-shadow(0 0 3px var(--accent-green)); }
        
    </style>
</head>
<body>

<div class="container">
    <header>
        <h1>Memristor Learning Simulator</h1>
    </header>

    <div class="sidebar">
        <!-- Mode Selection -->
        <div class="panel">
            <h3>Mode</h3>
            <button id="btn-mode-train" class="mode-toggle mode-active" onclick="setMode('training')">
                <span>TRAINING</span> <span>(Learn)</span>
            </button>
            <button id="btn-mode-infer" class="mode-toggle" onclick="setMode('inference')">
                <span>INFERENCE</span> <span>(Use)</span>
            </button>
        </div>

        <!-- Training Controls -->
        <div class="panel" id="panel-training">
            <h3>Training Data</h3>
            <div class="control-group">
                <label>Target Operation</label>
                <select id="operation-select" onchange="resetSimulation()">
                    <option value="x2">Multiplication (x2)</option>
                    <option value="x5">Multiplication (x5)</option>
                    <option value="div2">Division (/2)</option>
                    <option value="add100">Addition (+100)</option>
                </select>
            </div>
            
            <div class="training-data-list" id="training-list">
                <!-- Generated by JS -->
            </div>
            <br>
            <button class="primary" onclick="startTraining()">START TRAINING</button>
            <button onclick="resetSimulation()">RESET WEIGHT</button>
        </div>

        <!-- Inference Controls -->
        <div class="panel" id="panel-inference" style="display:none;">
            <h3>Test Input</h3>
            <label>Enter Value:</label>
            <input type="number" id="input-test" value="7" placeholder="Enter number...">
            <button class="primary" onclick="runInference()">COMPUTE</button>
            <div style="margin-top:20px; text-align:center;">
                <h2 id="inference-result">--</h2>
                <small>Result</small>
            </div>
        </div>
    </div>

    <div class="main-view">
        <!-- Physical Visualization -->
        <div class="visualization-area">
            <svg id="memristor-svg"></svg>
        </div>

        <div class="stats-bar">
            <div class="stat-item">Conductance (G): <span id="val-conductance">0.00</span> S</div>
            <div class="stat-item">Weight (W): <span id="val-weight">0.00</span></div>
            <div class="stat-item">Memristance (M): <span id="val-resistance">∞</span> Ω</div>
        </div>

        <!-- Computation Flow -->
        <div class="computation-view">
            <div class="math-equation">
                <span style="color:#aaa;">I</span> = <span style="color:#aaa;">V</span> × <span style="color:var(--accent-cyan);">W</span>
            </div>
            <div class="math-equation" id="live-equation">
                <span class="math-var" id="eq-i">0</span> = <span class="math-var" id="eq-v">0</span> × <span id="eq-w">0.00</span>
            </div>
        </div>
    </div>

    <div class="log-panel" id="log-panel">
        <div class="log-entry log-info">[System] Simulator initialized. Ready to train.</div>
    </div>
</div>

<script>
    // --- CONFIGURATION ---
    const CONFIG = {
        width: 800,
        height: 300,
        memristorX: 200,
        memristorY: 50,
        memristorW: 400,
        memristorH: 200,
        numIons: 40,
        learningRate: 0.05, // Increased for visible learning
        ionSpeed: 500 // Transition duration in ms
    };

    // --- STATE ---
    let state = {
        mode: 'training', // 'training' or 'inference'
        weight: 0.1, // Initial random small weight
        targetWeight: 2.0, // Goal (for x2)
        ions: [], // Array of {x, y}
        trainingData: [],
        isTraining: false,
        epoch: 0,
        dopingRatio: 0.05 // 0 to 1 (left to right)
    };

    // --- OPERATIONS ---
    const OPERATIONS = {
        'x2': { name: 'Multiply x2', fn: x => x * 2, weight: 2.0, examples: [1, 2, 3, 5, 8] },
        'x5': { name: 'Multiply x5', fn: x => x * 5, weight: 5.0, examples: [1, 2, 3, 4] },
        'div2': { name: 'Divide /2', fn: x => x / 2, weight: 0.5, examples: [2, 4, 10, 20] },
        'add100': { name: 'Add 1 (Dummy)', fn: x => x * 1, weight: 1.0, examples: [100, 200] } // Simplified representation
    };

    // --- LOGGING ---
    function log(msg, type='info') {
        const panel = document.getElementById('log-panel');
        const entry = document.createElement('div');
        entry.className = `log-entry log-${type}`;
        entry.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
        panel.prepend(entry);
    }

    // --- INITIALIZATION ---
    function init() {
        initD3();
        loadOperation('x2');
        generateIons();
        updateVisuals();
    }

    // --- PHYSICS MODEL ---
    function generateIons() {
        state.ions = [];
        // Scatter ions initially in the left side (doped region mostly) but randomly
        for(let i=0; i<CONFIG.numIons; i++) {
            state.ions.push({
                x: Math.random() * (CONFIG.memristorW * state.dopingRatio),
                y: Math.random() * (CONFIG.memristorH - 20) + 10,
                id: i
            });
        }
    }

    function updatePhysics(voltageProvided) {
        // Physical Principle:
        // V > 0: Ions move RIGHT (expanding doped region) -> Resistance Decreases -> Weight Increases
        // V < 0: Ions move LEFT (shrinking doped region) -> Resistance Increases -> Weight Decreases
        
        // Always sync doping ratio to weight for immediate visual feedback
        // Normalize weight: 5.0 is max visual width
        const targetRatio = Math.min(1, Math.max(0.05, state.weight / 5.0));
        state.dopingRatio = targetRatio;

        // Move ions to fill up to dopingRatio
        const boundaryX = CONFIG.memristorW * state.dopingRatio;
        
        state.ions.forEach(ion => {
            // Target X area: 0 to boundaryX
            let targetX = Math.random() * boundaryX;
            // Ease ion towards target
            ion.x = ion.x + (targetX - ion.x) * 0.1;
        });
    }

    // --- D3 VISUALIZATION ---
    let svg, gDevice, gIons, borderLine, dopedRect, undopedRect, electrodeTop, electrodeBot;

    function initD3() {
        svg = d3.select("#memristor-svg")
            .attr("viewBox", `0 0 ${CONFIG.width} ${CONFIG.height}`);

        const gContainer = svg.append("g")
            .attr("transform", `translate(${CONFIG.memristorX}, ${CONFIG.memristorY})`);

        // 1. Electrodes
        // Top
        gContainer.append("rect")
            .attr("x", -20).attr("y", -20)
            .attr("width", CONFIG.memristorW + 40).attr("height", 20)
            .attr("class", "electrode");
        gContainer.append("text")
            .attr("x", CONFIG.memristorW/2).attr("y", -5)
            .attr("class", "electrode-text")
            .text("TOP ELECTRODE (+V)");

        // Bottom
        gContainer.append("rect")
            .attr("x", -20).attr("y", CONFIG.memristorH)
            .attr("width", CONFIG.memristorW + 40).attr("height", 20)
            .attr("class", "electrode");
        gContainer.append("text")
            .attr("x", CONFIG.memristorW/2).attr("y", CONFIG.memristorH + 15)
            .attr("class", "electrode-text")
            .text("BOTTOM ELECTRODE (GND)");

        // 2. Channel Layers
        // Doped (Cyan) - Left side growing right
        dopedRect = gContainer.append("rect")
            .attr("x", 0).attr("y", 0)
            .attr("width", 10).attr("height", CONFIG.memristorH)
            .attr("class", "doped-region");

        // Undoped (Purple) - Filling the rest
        undopedRect = gContainer.append("rect")
            .attr("x", 10).attr("y", 0)
            .attr("width", CONFIG.memristorW - 10).attr("height", CONFIG.memristorH)
            .attr("class", "undoped-region");

        // Boundary Line
        borderLine = gContainer.append("line")
            .attr("x1", 10).attr("y1", 0)
            .attr("x2", 10).attr("y2", CONFIG.memristorH)
            .attr("stroke", "#fff")
            .attr("stroke-width", 2)
            .attr("stroke-dasharray", "4");

        // 3. Ions
        gIons = gContainer.append("g");
        
        updateVisuals();
    }

    function renderIons() {
        const ions = gIons.selectAll(".ion")
            .data(state.ions, d => d.id);

        ions.enter()
            .append("circle")
            .attr("class", "ion")
            .attr("r", 4)
            .merge(ions)
            .transition().duration(500).ease(d3.easeLinear)
            .attr("cx", d => d.x)
            .attr("cy", d => d.y);
            
        ions.exit().remove();

        // Update Regions
        const boundary = CONFIG.memristorW * state.dopingRatio;
        
        dopedRect.transition().duration(500)
            .attr("width", boundary);
            
        undopedRect.transition().duration(500)
            .attr("x", boundary)
            .attr("width", CONFIG.memristorW - boundary);

        borderLine.transition().duration(500)
            .attr("x1", boundary).attr("x2", boundary);
    }

    function animateCurrent(inputVal) {
        // Create particles flowing from top to bottom
        // Speed/Density proportional to Output Current
        const outputVal = inputVal * state.weight;
        const numParticles = Math.min(20, Math.floor(outputVal / 2)); 
        
        const gContainer = d3.select("g"); // select the transformed group
        
        for(let i=0; i<numParticles; i++) {
            gContainer.append("circle")
                .attr("class", "current-particle")
                .attr("r", 3)
                .attr("cx", Math.random() * CONFIG.memristorW)
                .attr("cy", -10)
                .attr("opacity", 1)
                .transition()
                .delay(i * 100)
                .duration(1000)
                .ease(d3.easeLinear)
                .attr("cy", CONFIG.memristorH + 10)
                .on("end", function() { d3.select(this).remove(); });
        }
    }

    // --- LOGIC & UI ---
    function updateVisuals() {
        // Update stats
        document.getElementById('val-weight').innerText = state.weight.toFixed(2);
        const conductance = state.weight / 100; // Arbitrary scale for display
        document.getElementById('val-conductance').innerText = conductance.toFixed(4);
        const resistance = conductance > 0 ? (1/conductance).toFixed(0) : "∞";
        document.getElementById('val-resistance').innerText = resistance;

        // Render Ions
        updatePhysics(0); // Move ions to match state.dopingRatio
        renderIons();
    }

    function resetSimulation() {
        state.weight = Math.random() * 0.5; // Reset to low random
        state.dopingRatio = 0.05;
        state.epoch = 0;
        state.isTraining = false;
        
        // Reload Target
        const opKey = document.getElementById('operation-select').value;
        loadOperation(opKey);
        
        updateVisuals();
        log("Weights reset. Ready to learn.");
        
        // Clear equations
        document.getElementById('inference-result').innerText = "--";
    }

    function loadOperation(key) {
        const op = OPERATIONS[key];
        state.targetWeight = op.weight;
        state.trainingData = op.examples.map(x => ({ input: x, expected: op.fn(x) }));
        
        // Update UI List
        const list = document.getElementById('training-list');
        list.innerHTML = '';
        state.trainingData.forEach(d => {
            const row = document.createElement('div');
            row.className = 'data-row';
            row.innerHTML = `<span>${d.input} -> ${d.expected}</span> <span>Wait</span>`;
            list.appendChild(row);
        });
    }

    function setMode(mode) {
        state.mode = mode;
        if(mode === 'training') {
            document.getElementById('panel-training').style.display = 'block';
            document.getElementById('panel-inference').style.display = 'none';
            document.getElementById('btn-mode-train').classList.add('mode-active');
            document.getElementById('btn-mode-infer').classList.remove('mode-active');
        } else {
            document.getElementById('panel-training').style.display = 'none';
            document.getElementById('panel-inference').style.display = 'block';
            document.getElementById('btn-mode-train').classList.remove('mode-active');
            document.getElementById('btn-mode-infer').classList.add('mode-active');
        }
    }

    // --- TRAINING LOOP ---
    async function startTraining() {
        if(state.isTraining) return;
        state.isTraining = true;
        log("Training started...", "info");

        const dataRows = document.querySelectorAll('.data-row');
        
        for (let epoch = 1; epoch <= 10; epoch++) {
            let totalError = 0;
            log(`Epoch ${epoch} started...`, "info");
            
            for (let i = 0; i < state.trainingData.length; i++) {
                const data = state.trainingData[i];
                
                // Highlight UI
                dataRows.forEach(r => r.classList.remove('active'));
                if(dataRows[i]) dataRows[i].classList.add('active');

                // 1. Forward Pass
                const predicted = data.input * state.weight;
                const error = data.expected - predicted;
                
                // 2. Training Step (Gradient Descent)
                // W_new = W_old + (learning_rate * error * input)
                const oldWeight = state.weight;
                const delta = CONFIG.learningRate * error * data.input;
                state.weight += delta;
                
                // Clamp
                if(state.weight < 0) state.weight = 0;
                
                totalError += Math.abs(error);

                // 3. Visualize
                updateVisuals();
                
                // Update Equation UI
                document.getElementById('eq-i').innerText = predicted.toFixed(1);
                document.getElementById('eq-v').innerText = data.input;
                document.getElementById('eq-w').innerText = state.weight.toFixed(2);

                // Wait for animation
                await new Promise(r => setTimeout(r, 800));
            }
            
            if (totalError < 0.1) {
                log(`Converged at Epoch ${epoch}! Final Weight: ${state.weight.toFixed(2)}`, "success");
                break;
            }
        }
        
        state.isTraining = false;
        dataRows.forEach(r => r.classList.remove('active'));
        log("Training Complete.", "success");
    }

    // --- INFERENCE ---
    function runInference() {
        const input = parseFloat(document.getElementById('input-test').value);
        if(isNaN(input)) return;

        // Animate
        animateCurrent(input);
        
        // Calculate
        const result = input * state.weight;
        
        // Show Math
        document.getElementById('eq-i').innerText = result.toFixed(1);
        document.getElementById('eq-v').innerText = input;
        document.getElementById('eq-w').innerText = state.weight.toFixed(2);
        
        // Show Result
        const resEl = document.getElementById('inference-result');
        resEl.style.opacity = 0;
        setTimeout(() => {
            resEl.innerText = result.toFixed(1);
            resEl.style.opacity = 1;
        }, 1000); // Delay for current animation
        
        log(`Inference: Input ${input} * Weight ${state.weight.toFixed(2)} = ${result.toFixed(2)}`, "info");
    }

    // Initialize
    init();

</script>
</body>
</html>
