<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memristor Learning Simulator</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@300;500;700&display=swap');

        :root {
            --bg-color: #0a0e17;
            --panel-bg: #121a2e;
            --text-main: #e0e6ed;
            --accent-cyan: #00f5ff;
            --accent-purple: #9d00ff;
            --accent-green: #00ff88;
            --accent-magenta: #ff00aa;
            --accent-orange: #ffaa00;
            --border-color: #2a3b55;
            --ion-color: #ffaa00;
            --undoped-color: #2a1a4a;
            --doped-color: #00f5ff; /* Opacity will be handled in JS */
        }

        body {
            font-family: 'Rajdhani', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            box-sizing: border-box;
        }

        h1, h2, h3, h4 {
            font-family: 'Orbitron', sans-serif;
            margin: 0 0 10px 0;
            color: var(--accent-cyan);
            text-transform: uppercase;
        }

        .container {
            display: grid;
            grid-template-columns: 300px 1fr;
            grid-template-rows: auto 1fr auto;
            gap: 20px;
            width: 100%;
            max-width: 1400px;
            height: 100%;
            border: 1px solid var(--border-color);
            background: rgba(18, 26, 46, 0.5);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.1);
        }

        /* Header */
        header {
            grid-column: 1 / -1;
            border-bottom: 2px solid var(--accent-cyan);
            padding-bottom: 10px;
            text-align: center;
            text-shadow: 0 0 10px var(--accent-cyan);
        }

        /* Sidebar: Controls & Data */
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
        }

        .panel {
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            padding: 15px;
            border-radius: 5px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            color: var(--accent-cyan);
            font-size: 0.9em;
        }

        select, input, button {
            width: 100%;
            padding: 8px;
            background: #05080e;
            border: 1px solid var(--border-color);
            color: var(--text-main);
            font-family: 'Orbitron', sans-serif;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        button:hover {
            border-color: var(--accent-cyan);
            box-shadow: 0 0 10px rgba(0, 245, 255, 0.2);
        }
        
        button.primary {
            background: rgba(0, 245, 255, 0.1);
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }

        button.mode-toggle {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .mode-active {
            background: var(--accent-cyan) !important;
            color: #000 !important;
        }

        .training-data-list {
            max-height: 200px;
            overflow-y: auto;
            font-size: 0.9em;
        }

        .data-row {
            display: flex;
            justify-content: space-between;
            padding: 5px;
            border-bottom: 1px solid #1e2a45;
        }
        
        .data-row.active {
            background: rgba(0, 255, 136, 0.1);
            border-left: 3px solid var(--accent-green);
        }

        /* Main View */
        .main-view {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .visualization-area {
            flex: 1;
            background: #000;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            position: relative;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #memristor-svg {
            width: 100%;
            height: 100%;
        }

        .stats-bar {
            display: flex;
            justify-content: space-around;
            background: var(--panel-bg);
            padding: 10px;
            border: 1px solid var(--border-color);
            font-family: 'Orbitron', monospace;
            font-size: 1.2em;
        }
        
        .stat-item span {
            color: var(--accent-orange);
        }

        .computation-view {
            height: 150px;
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            position: relative;
        }
        
        /* Inference explanation panel */
        .inference-explanation {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 280px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid var(--accent-cyan);
            border-radius: 8px;
            padding: 15px;
            font-family: 'Rajdhani', sans-serif;
            z-index: 100;
            display: none;
        }
        
        .inference-explanation.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }
        
        .inference-explanation h4 {
            margin: 0 0 10px 0;
            color: var(--accent-cyan);
            font-size: 14px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 5px;
        }
        
        .inference-explanation .step {
            margin: 8px 0;
            padding: 8px;
            background: rgba(255,255,255,0.05);
            border-radius: 4px;
            opacity: 0.3;
            transition: all 0.3s;
        }
        
        .inference-explanation .step.active {
            opacity: 1;
            border-left: 3px solid var(--accent-green);
            background: rgba(0, 255, 136, 0.1);
        }
        
        .inference-explanation .step.completed {
            opacity: 0.7;
            border-left: 3px solid var(--accent-cyan);
        }
        
        .step-number {
            display: inline-block;
            width: 20px;
            height: 20px;
            background: var(--accent-cyan);
            color: #000;
            border-radius: 50%;
            text-align: center;
            line-height: 20px;
            font-size: 12px;
            font-weight: bold;
            margin-right: 8px;
        }
        
        .step-math {
            display: block;
            margin-top: 5px;
            font-family: 'Orbitron', sans-serif;
            color: var(--accent-orange);
            font-size: 13px;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .math-equation {
            font-size: 2em;
            font-family: 'Orbitron', sans-serif;
            display: flex;
            gap: 15px;
            align-items: center;
        }
        
        .math-var {
            color: var(--accent-green);
        }

        /* Logs */
        .log-panel {
            grid-column: 1 / -1;
            height: 150px;
            background: #000;
            border: 1px solid var(--border-color);
            padding: 10px;
            font-family: 'Consolas', monospace;
            font-size: 0.85em;
            overflow-y: auto;
            color: #888;
        }
        
        .log-entry { margin-bottom: 2px; }
        .log-info { color: #888; }
        .log-success { color: var(--accent-green); }
        .log-warn { color: var(--accent-orange); }

        /* SVG Styles */
        .electrode { fill: #555; stroke: #888; stroke-width: 2; }
        .electrode-text { font-family: 'Orbitron', sans-serif; font-size: 14px; fill: #aaa; text-anchor: middle; }
        .doped-region { fill: var(--doped-color); opacity: 0.3; }
        .undoped-region { fill: var(--undoped-color); }
        .ion { fill: var(--ion-color); filter: drop-shadow(0 0 2px var(--ion-color)); }
        .current-particle { fill: var(--accent-green); filter: drop-shadow(0 0 3px var(--accent-green)); }
        
    </style>
</head>
<body>

<div class="container">
    <header>
        <h1>Memristor Learning Simulator</h1>
    </header>

    <div class="sidebar">
        <!-- Mode Selection -->
        <div class="panel">
            <h3>Mode</h3>
            <button id="btn-mode-train" class="mode-toggle mode-active" onclick="setMode('training')">
                <span>TRAINING</span> <span>(Learn)</span>
            </button>
            <button id="btn-mode-infer" class="mode-toggle" onclick="setMode('inference')">
                <span>INFERENCE</span> <span>(Use)</span>
            </button>
        </div>

        <!-- Training Controls -->
        <div class="panel" id="panel-training">
            <h3>Training Data</h3>
            <div class="control-group">
                <label>Target Operation</label>
                <select id="operation-select" onchange="resetSimulation()">
                    <option value="x2">Multiplication (x2)</option>
                    <option value="x5">Multiplication (x5)</option>
                    <option value="div2">Division (/2)</option>
                    <option value="add100">Addition (+100)</option>
                </select>
            </div>
            
            <div class="training-data-list" id="training-list">
                <!-- Generated by JS -->
            </div>
            <br>
            <button class="primary" onclick="startTraining()">START TRAINING</button>
            <button onclick="resetSimulation()">RESET WEIGHT</button>
        </div>

        <!-- Inference Controls -->
        <div class="panel" id="panel-inference" style="display:none;">
            <h3>Test Input</h3>
            <label>Enter Value:</label>
            <input type="number" id="input-test" value="7" placeholder="Enter number...">
            <button class="primary" onclick="runInference()">COMPUTE</button>
            <div style="margin-top:20px; text-align:center;">
                <h2 id="inference-result">--</h2>
                <small>Result</small>
            </div>
        </div>
    </div>

    <div class="main-view">
        <!-- Physical Visualization -->
        <div class="visualization-area">
            <svg id="memristor-svg"></svg>
            
            <!-- Inference Explanation Panel -->
            <div class="inference-explanation" id="inference-explanation">
                <h4>üîç HOE BEREKENT DE MEMRISTOR?</h4>
                <div class="step" id="step1">
                    <span class="step-number">1</span>
                    <span class="step-text">INPUT: Signaal komt binnen</span>
                    <span class="step-math" id="step1-math">V = ?</span>
                </div>
                <div class="step" id="step2">
                    <span class="step-number">2</span>
                    <span class="step-text">WEIGHT: Kanaal breedte bepaalt vermenigvuldiging</span>
                    <span class="step-math" id="step2-math">W = ?</span>
                </div>
                <div class="step" id="step3">
                    <span class="step-number">3</span>
                    <span class="step-text">BEREKENING: Elk input-deeltje ‚Üí W output-deeltjes</span>
                    <span class="step-math" id="step3-math">? √ó ? = ?</span>
                </div>
                <div class="step" id="step4">
                    <span class="step-number">4</span>
                    <span class="step-text">OUTPUT: Resultaat stroomt uit</span>
                    <span class="step-math" id="step4-math">I = ?</span>
                </div>
            </div>
        </div>

        <div class="stats-bar">
            <div class="stat-item">Conductance (G): <span id="val-conductance">0.00</span> S</div>
            <div class="stat-item">Weight (W): <span id="val-weight">0.00</span></div>
            <div class="stat-item">Memristance (M): <span id="val-resistance">‚àû</span> Œ©</div>
        </div>

        <!-- Computation Flow -->
        <div class="computation-view">
            <div class="math-equation">
                <span style="color:#aaa;">I</span> = <span style="color:#aaa;">V</span> √ó <span style="color:var(--accent-cyan);">W</span>
            </div>
            <div class="math-equation" id="live-equation">
                <span class="math-var" id="eq-i">0</span> = <span class="math-var" id="eq-v">0</span> √ó <span id="eq-w">0.00</span>
            </div>
        </div>
    </div>

    <div class="log-panel" id="log-panel">
        <div class="log-entry log-info">[System] Simulator initialized. Ready to train.</div>
    </div>
</div>

<script>
    // --- CONFIGURATION ---
    const CONFIG = {
        width: 900,
        height: 420,
        memristorX: 200,
        memristorY: 50,
        memristorW: 400,
        memristorH: 200,
        numIons: 40,
        learningRate: 0.05, // Increased for visible learning
        ionSpeed: 500 // Transition duration in ms
    };

    // --- STATE ---
    let state = {
        mode: 'training', // 'training' or 'inference'
        weight: 0.1, // Initial random small weight
        targetWeight: 2.0, // Goal (for x2)
        ions: [], // Array of {x, y}
        trainingData: [],
        isTraining: false,
        epoch: 0,
        dopingRatio: 0.05 // 0 to 1 (left to right)
    };

    // --- OPERATIONS ---
    const OPERATIONS = {
        'x2': { name: 'Multiply x2', fn: x => x * 2, weight: 2.0, examples: [1, 2, 3, 5, 8] },
        'x5': { name: 'Multiply x5', fn: x => x * 5, weight: 5.0, examples: [1, 2, 3, 4] },
        'div2': { name: 'Divide /2', fn: x => x / 2, weight: 0.5, examples: [2, 4, 10, 20] },
        'add100': { name: 'Add 1 (Dummy)', fn: x => x * 1, weight: 1.0, examples: [100, 200] } // Simplified representation
    };

    // --- LOGGING ---
    function log(msg, type='info') {
        const panel = document.getElementById('log-panel');
        const entry = document.createElement('div');
        entry.className = `log-entry log-${type}`;
        entry.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
        panel.prepend(entry);
    }

    // --- INITIALIZATION ---
    function init() {
        initD3();
        loadOperation('x2');
        generateIons();
        updateVisuals();
    }

    // --- PHYSICS MODEL ---
    function generateIons() {
        state.ions = [];
        // Scatter ions initially in the left side (doped region mostly) but randomly
        for(let i=0; i<CONFIG.numIons; i++) {
            state.ions.push({
                x: Math.random() * (CONFIG.memristorW * state.dopingRatio),
                y: Math.random() * (CONFIG.memristorH - 20) + 10,
                id: i
            });
        }
    }

    function updatePhysics(voltageProvided) {
        // Physical Principle:
        // V > 0: Ions move RIGHT (expanding doped region) -> Resistance Decreases -> Weight Increases
        // V < 0: Ions move LEFT (shrinking doped region) -> Resistance Increases -> Weight Decreases
        
        // Always sync doping ratio to weight for immediate visual feedback
        // Normalize weight: 5.0 is max visual width
        const targetRatio = Math.min(1, Math.max(0.05, state.weight / 5.0));
        state.dopingRatio = targetRatio;

        // Move ions to fill up to dopingRatio
        const boundaryX = CONFIG.memristorW * state.dopingRatio;
        
        state.ions.forEach(ion => {
            // Target X area: 0 to boundaryX
            let targetX = Math.random() * boundaryX;
            // Ease ion towards target
            ion.x = ion.x + (targetX - ion.x) * 0.1;
        });
        
        // --- ANNOTATIONS ---
        // Dynamically update labels to explain the "Why"
        const gAnnotations = d3.select("g").selectAll(".annotation").data([1]);
        const gAnnEnter = gAnnotations.enter().append("g").attr("class", "annotation");
        
        // 1. Voltage/Input Label
        gAnnEnter.append("text")
            .attr("x", -150).attr("y", buffer => CONFIG.memristorH/2)
            .attr("fill", "#ccc").attr("font-size", "12px")
            .text("INPUT (Voltage/Energy)");
            
        // 2. Conductance/Weight Label
        // Positioned at the boundary line
        d3.select(".boundary-label").remove(); // Clear old
        d3.select("g").append("text")
            .attr("class", "boundary-label")
            .attr("x", boundaryX + 10).attr("y", CONFIG.memristorH/2)
            .attr("fill", "var(--accent-cyan)").attr("font-size", "14px")
            .text(`WIDTH = WEIGHT (${state.weight.toFixed(2)})`);
            
        // 3. Current/Output Label (only during infer)
        d3.select(".output-label").remove();
        if(state.mode === 'inference') {
             d3.select("g").append("text")
                .attr("class", "output-label")
                .attr("x", CONFIG.memristorW/2).attr("y", CONFIG.memristorH + 40)
                .attr("fill", "var(--accent-green)").attr("font-size", "14px").attr("text-anchor", "middle")
                .text(`FLOW = RESULT (${(state.weight * parseFloat(document.getElementById('input-test').value || 0)).toFixed(1)})`);
        }
    }

    // --- D3 VISUALIZATION ---
    let svg, gDevice, gIons, borderLine, dopedRect, undopedRect, electrodeTop, electrodeBot;

    function initD3() {
        svg = d3.select("#memristor-svg")
            .attr("viewBox", `0 0 ${CONFIG.width} ${CONFIG.height}`);

        const gContainer = svg.append("g")
            .attr("transform", `translate(${CONFIG.memristorX}, ${CONFIG.memristorY})`);

        // 1. Electrodes
        // Top
        gContainer.append("rect")
            .attr("x", -20).attr("y", -20)
            .attr("width", CONFIG.memristorW + 40).attr("height", 20)
            .attr("class", "electrode");
        gContainer.append("text")
            .attr("x", CONFIG.memristorW/2).attr("y", -5)
            .attr("class", "electrode-text")
            .text("TOP ELECTRODE (+V)");

        // Bottom
        gContainer.append("rect")
            .attr("x", -20).attr("y", CONFIG.memristorH)
            .attr("width", CONFIG.memristorW + 40).attr("height", 20)
            .attr("class", "electrode");
        gContainer.append("text")
            .attr("x", CONFIG.memristorW/2).attr("y", CONFIG.memristorH + 15)
            .attr("class", "electrode-text")
            .text("BOTTOM ELECTRODE (GND)");

        // 2. Channel Layers
        // Doped (Cyan) - Left side growing right
        dopedRect = gContainer.append("rect")
            .attr("x", 0).attr("y", 0)
            .attr("width", 10).attr("height", CONFIG.memristorH)
            .attr("class", "doped-region");

        // Undoped (Purple) - Filling the rest
        undopedRect = gContainer.append("rect")
            .attr("x", 10).attr("y", 0)
            .attr("width", CONFIG.memristorW - 10).attr("height", CONFIG.memristorH)
            .attr("class", "undoped-region");

        // Boundary Line
        borderLine = gContainer.append("line")
            .attr("x1", 10).attr("y1", 0)
            .attr("x2", 10).attr("y2", CONFIG.memristorH)
            .attr("stroke", "#fff")
            .attr("stroke-width", 2)
            .attr("stroke-dasharray", "4");

        // 3. Ions
        gIons = gContainer.append("g");
        
        updateVisuals();
    }

    function renderIons() {
        const ions = gIons.selectAll(".ion")
            .data(state.ions, d => d.id);

        ions.enter()
            .append("circle")
            .attr("class", "ion")
            .attr("r", 4)
            .merge(ions)
            .transition().duration(500).ease(d3.easeLinear)
            .attr("cx", d => d.x)
            .attr("cy", d => d.y);
            
        ions.exit().remove();

        // Update Regions
        const boundary = CONFIG.memristorW * state.dopingRatio;
        
        dopedRect.transition().duration(500)
            .attr("width", boundary);
            
        undopedRect.transition().duration(500)
            .attr("x", boundary)
            .attr("width", CONFIG.memristorW - boundary);

        borderLine.transition().duration(500)
            .attr("x1", boundary).attr("x2", boundary);
    }

    function animateCurrent(inputVal) {
        // VISUAL ANALOGY: The "Calculation" IS the flow.
        // Input (Voltage) pushes particles.
        // Weight (Conductance) is the WIDTH of the pipe.
        // Result (Current) is how much gets through.
        
        // 1. Calculate the 'Pipe Width' (Doped Region)
        const pipeWidth = CONFIG.memristorW * state.dopingRatio;
        
        // 2. Determine number of particles (Result)
        const outputVal = inputVal * state.weight;
        const numParticles = Math.min(50, Math.floor(outputVal * 2)); 
        
        const gContainer = d3.select("g"); 
        
        for(let i=0; i<numParticles; i++) {
            // 3. Constrain particles to flow ONLY through the conductive pipe
            // This visually proves that "Wider Pipe = More Flow"
            const startX = Math.random() * pipeWidth;
            
            gContainer.append("circle")
                .attr("class", "current-particle")
                .attr("r", 3)
                .attr("cx", startX) // Constrained to doped width
                .attr("cy", -10)
                .attr("opacity", 0.8)
                .transition()
                .delay(i * 50)
                .duration(1500) // Consistent speed
                .ease(d3.easeLinear)
                .attr("cy", CONFIG.memristorH + 10)
                .on("end", function() { d3.select(this).remove(); });
        }
        
        // Show explanatory toast
        log(`Physics: ${inputVal}V pushed through a ${pipeWidth.toFixed(0)}px wide pipe.`, "info");
    }

    // --- LOGIC & UI ---
    function updateVisuals() {
        // Update stats
        document.getElementById('val-weight').innerText = state.weight.toFixed(2);
        const conductance = state.weight / 100; // Arbitrary scale for display
        document.getElementById('val-conductance').innerText = conductance.toFixed(4);
        const resistance = conductance > 0 ? (1/conductance).toFixed(0) : "‚àû";
        document.getElementById('val-resistance').innerText = resistance;

        // Render Ions
        updatePhysics(0); // Move ions to match state.dopingRatio
        renderIons();
    }

    function resetSimulation() {
        state.weight = Math.random() * 0.5; // Reset to low random
        state.dopingRatio = 0.05;
        state.epoch = 0;
        state.isTraining = false;
        
        // Reload Target
        const opKey = document.getElementById('operation-select').value;
        loadOperation(opKey);
        
        updateVisuals();
        log("Weights reset. Ready to learn.");
        
        // Clear equations
        document.getElementById('inference-result').innerText = "--";
    }

    function loadOperation(key) {
        const op = OPERATIONS[key];
        state.targetWeight = op.weight;
        state.trainingData = op.examples.map(x => ({ input: x, expected: op.fn(x) }));
        
        // Update UI List
        const list = document.getElementById('training-list');
        list.innerHTML = '';
        state.trainingData.forEach(d => {
            const row = document.createElement('div');
            row.className = 'data-row';
            row.innerHTML = `<span>${d.input} -> ${d.expected}</span> <span>Wait</span>`;
            list.appendChild(row);
        });
    }

    function setMode(mode) {
        state.mode = mode;
        if(mode === 'training') {
            document.getElementById('panel-training').style.display = 'block';
            document.getElementById('panel-inference').style.display = 'none';
            document.getElementById('btn-mode-train').classList.add('mode-active');
            document.getElementById('btn-mode-infer').classList.remove('mode-active');
        } else {
            document.getElementById('panel-training').style.display = 'none';
            document.getElementById('panel-inference').style.display = 'block';
            document.getElementById('btn-mode-train').classList.remove('mode-active');
            document.getElementById('btn-mode-infer').classList.add('mode-active');
        }
    }

    // --- TRAINING LOOP ---
    async function startTraining() {
        if(state.isTraining) return;
        state.isTraining = true;
        log("Training started...", "info");

        const dataRows = document.querySelectorAll('.data-row');
        
        for (let epoch = 1; epoch <= 10; epoch++) {
            let totalError = 0;
            log(`Epoch ${epoch} started...`, "info");
            
            for (let i = 0; i < state.trainingData.length; i++) {
                const data = state.trainingData[i];
                
                // Highlight UI
                dataRows.forEach(r => r.classList.remove('active'));
                if(dataRows[i]) dataRows[i].classList.add('active');

                // 1. Forward Pass
                const predicted = data.input * state.weight;
                const error = data.expected - predicted;
                
                // 2. Training Step (Gradient Descent)
                // W_new = W_old + (learning_rate * error * input)
                const oldWeight = state.weight;
                const delta = CONFIG.learningRate * error * data.input;
                state.weight += delta;
                
                // Clamp
                if(state.weight < 0) state.weight = 0;
                
                totalError += Math.abs(error);

                // 3. Visualize
                updateVisuals();
                
                // Update Equation UI
                document.getElementById('eq-i').innerText = predicted.toFixed(1);
                document.getElementById('eq-v').innerText = data.input;
                document.getElementById('eq-w').innerText = state.weight.toFixed(2);

                // Wait for animation
                await new Promise(r => setTimeout(r, 800));
            }
            
            if (totalError < 0.1) {
                log(`Converged at Epoch ${epoch}! Final Weight: ${state.weight.toFixed(2)}`, "success");
                break;
            }
        }
        
        state.isTraining = false;
        dataRows.forEach(r => r.classList.remove('active'));
        log("Training Complete.", "success");
    }

    // --- INFERENCE ---
    let inferenceRunning = false;
    
    async function runInference() {
        if(inferenceRunning) return;
        inferenceRunning = true;
        
        const input = parseFloat(document.getElementById('input-test').value);
        if(isNaN(input) || input <= 0) {
            inferenceRunning = false;
            log("Please enter a positive number.", "warn");
            return;
        }

        const result = input * state.weight;
        const gContainer = d3.select("#memristor-svg g");
        
        // Clear any previous inference elements
        gContainer.selectAll(".inference-element").remove();
        gContainer.selectAll(".current-particle").remove();
        
        // Reset equation display
        document.getElementById('eq-i').innerText = '?';
        document.getElementById('eq-v').innerText = input;
        document.getElementById('eq-w').innerText = state.weight.toFixed(2);
        document.getElementById('inference-result').innerText = '...';
        
        // Calculate visual parameters
        const pipeWidth = CONFIG.memristorW * state.dopingRatio;
        const inputParticleCount = Math.min(25, Math.max(3, Math.floor(input / 2)));
        
        // ===== PHASE 1: SHOW INPUT ENTERING =====
        log(`Phase 1: Input signal V=${input} arriving...`, "info");
        
        // Create input indicator bar on the left
        const inputBarHeight = Math.min(CONFIG.memristorH - 20, input * 6);
        const inputBar = gContainer.append("rect")
            .attr("class", "inference-element")
            .attr("x", -100)
            .attr("y", CONFIG.memristorH/2)
            .attr("width", 40)
            .attr("height", 0)
            .attr("fill", "url(#inputGradient)")
            .attr("opacity", 0.9)
            .attr("rx", 5);
        
        // Add gradient definition if not exists
        let defs = d3.select("#memristor-svg defs");
        if(defs.empty()) {
            defs = d3.select("#memristor-svg").append("defs");
            
            const inputGrad = defs.append("linearGradient")
                .attr("id", "inputGradient")
                .attr("x1", "0%").attr("y1", "0%")
                .attr("x2", "100%").attr("y2", "0%");
            inputGrad.append("stop").attr("offset", "0%").attr("stop-color", "#ff6600");
            inputGrad.append("stop").attr("offset", "100%").attr("stop-color", "#ffaa00");
            
            const outputGrad = defs.append("linearGradient")
                .attr("id", "outputGradient")
                .attr("x1", "0%").attr("y1", "0%")
                .attr("x2", "100%").attr("y2", "0%");
            outputGrad.append("stop").attr("offset", "0%").attr("stop-color", "#00ff88");
            outputGrad.append("stop").attr("offset", "100%").attr("stop-color", "#00ffcc");
        }
        
        // Input label
        const inputLabel = gContainer.append("text")
            .attr("class", "inference-element")
            .attr("x", -80)
            .attr("y", CONFIG.memristorH/2 - inputBarHeight/2 - 15)
            .attr("fill", "var(--accent-orange)")
            .attr("font-size", "18px")
            .attr("font-family", "Orbitron")
            .attr("text-anchor", "middle")
            .attr("opacity", 0)
            .text(`INPUT`);
        
        const inputValue = gContainer.append("text")
            .attr("class", "inference-element")
            .attr("x", -80)
            .attr("y", CONFIG.memristorH/2 + 5)
            .attr("fill", "#fff")
            .attr("font-size", "24px")
            .attr("font-family", "Orbitron")
            .attr("font-weight", "bold")
            .attr("text-anchor", "middle")
            .attr("opacity", 0)
            .text(input);
        
        // Animate input bar growing
        inputBar.transition().duration(600)
            .attr("y", CONFIG.memristorH/2 - inputBarHeight/2)
            .attr("height", inputBarHeight);
        
        inputLabel.transition().delay(200).duration(400).attr("opacity", 1);
        inputValue.transition().delay(400).duration(400).attr("opacity", 1);
        
        await new Promise(r => setTimeout(r, 1000));
        
        // ===== PHASE 2: SHOW PARTICLES ENTERING HORIZONTALLY =====
        log(`Phase 2: ${inputParticleCount} energy units entering the channel...`, "info");
        
        // Create input particles that move from left into the device
        const inputParticles = [];
        for(let i = 0; i < inputParticleCount; i++) {
            const yPos = (CONFIG.memristorH / (inputParticleCount + 1)) * (i + 1);
            const particle = gContainer.append("circle")
                .attr("class", "inference-element input-particle")
                .attr("cx", -50)
                .attr("cy", yPos)
                .attr("r", 6)
                .attr("fill", "var(--accent-orange)")
                .attr("filter", "drop-shadow(0 0 4px #ffaa00)");
            inputParticles.push({el: particle, y: yPos});
        }
        
        // Animate particles moving into the channel (but stopping at the pipe width)
        inputParticles.forEach((p, i) => {
            p.el.transition()
                .delay(i * 80)
                .duration(800)
                .attr("cx", pipeWidth / 2); // Stop in the middle of the conductive region
        });
        
        // Show annotation: "Weight determines how much passes through"
        const weightAnnotation = gContainer.append("text")
            .attr("class", "inference-element")
            .attr("x", pipeWidth / 2)
            .attr("y", -35)
            .attr("fill", "var(--accent-cyan)")
            .attr("font-size", "14px")
            .attr("font-family", "Rajdhani")
            .attr("text-anchor", "middle")
            .attr("opacity", 0)
            .text(`‚¨á WEIGHT (W=${state.weight.toFixed(2)}) = Channel Width`);
        
        weightAnnotation.transition().delay(500).duration(400).attr("opacity", 1);
        
        await new Promise(r => setTimeout(r, 1500));
        
        // ===== PHASE 3: MULTIPLICATION VISUALIZATION =====
        log(`Phase 3: Multiplying ${input} √ó ${state.weight.toFixed(2)}...`, "info");
        
        // Show the multiplication happening
        const multiplyText = gContainer.append("text")
            .attr("class", "inference-element")
            .attr("x", pipeWidth / 2)
            .attr("y", CONFIG.memristorH / 2)
            .attr("fill", "#fff")
            .attr("font-size", "20px")
            .attr("font-family", "Orbitron")
            .attr("text-anchor", "middle")
            .attr("opacity", 0)
            .text(`${input} √ó ${state.weight.toFixed(2)}`);
        
        multiplyText.transition().duration(400).attr("opacity", 1);
        
        await new Promise(r => setTimeout(r, 800));
        
        // Transform input particles - some pass through, quantity based on weight
        // Visual: particles split/transform based on weight
        const outputParticleCount = Math.min(40, Math.max(1, Math.floor(result / 2)));
        
        // Fade out input particles
        inputParticles.forEach((p, i) => {
            p.el.transition()
                .delay(i * 30)
                .duration(300)
                .attr("opacity", 0.3);
        });
        
        // Fade out multiply text
        multiplyText.transition().delay(300).duration(300).attr("opacity", 0);
        
        await new Promise(r => setTimeout(r, 600));
        
        // ===== PHASE 4: OUTPUT EMERGES =====
        log(`Phase 4: Result = ${result.toFixed(1)} emerges as output current...`, "success");
        
        // Create output particles that flow downward (through the bottom electrode)
        for(let i = 0; i < outputParticleCount; i++) {
            const xPos = Math.random() * pipeWidth; // Constrained to pipe width!
            const delay = i * 60;
            
            gContainer.append("circle")
                .attr("class", "current-particle")
                .attr("cx", xPos)
                .attr("cy", 0)
                .attr("r", 5)
                .attr("fill", "var(--accent-green)")
                .attr("filter", "drop-shadow(0 0 5px #00ff88)")
                .attr("opacity", 0.9)
                .transition()
                .delay(delay)
                .duration(1200)
                .ease(d3.easeLinear)
                .attr("cy", CONFIG.memristorH + 30)
                .on("end", function() { d3.select(this).remove(); });
        }
        
        // Create output collector/bar at the bottom
        const outputBarWidth = Math.min(pipeWidth, result * 4);
        const outputBar = gContainer.append("rect")
            .attr("class", "inference-element")
            .attr("x", pipeWidth/2)
            .attr("y", CONFIG.memristorH + 45)
            .attr("width", 0)
            .attr("height", 30)
            .attr("fill", "url(#outputGradient)")
            .attr("opacity", 0.9)
            .attr("rx", 5);
        
        const outputLabel = gContainer.append("text")
            .attr("class", "inference-element")
            .attr("x", pipeWidth/2)
            .attr("y", CONFIG.memristorH + 95)
            .attr("fill", "var(--accent-green)")
            .attr("font-size", "16px")
            .attr("font-family", "Orbitron")
            .attr("text-anchor", "middle")
            .attr("opacity", 0)
            .text(`OUTPUT`);
        
        const outputValue = gContainer.append("text")
            .attr("class", "inference-element")
            .attr("x", pipeWidth/2)
            .attr("y", CONFIG.memristorH + 115)
            .attr("fill", "#fff")
            .attr("font-size", "28px")
            .attr("font-family", "Orbitron")
            .attr("font-weight", "bold")
            .attr("text-anchor", "middle")
            .attr("opacity", 0)
            .text(result.toFixed(1));
        
        // Animate output bar growing
        outputBar.transition()
            .delay(600)
            .duration(800)
            .attr("x", pipeWidth/2 - outputBarWidth/2)
            .attr("width", outputBarWidth);
        
        outputLabel.transition().delay(1000).duration(400).attr("opacity", 1);
        outputValue.transition().delay(1200).duration(400).attr("opacity", 1);
        
        // Update the equation display progressively
        await new Promise(r => setTimeout(r, 800));
        document.getElementById('eq-i').innerText = result.toFixed(1);
        
        await new Promise(r => setTimeout(r, 600));
        
        // Show final result
        document.getElementById('inference-result').innerText = result.toFixed(1);
        
        // Final explanation annotation
        const explanationText = gContainer.append("text")
            .attr("class", "inference-element")
            .attr("x", CONFIG.memristorW / 2)
            .attr("y", CONFIG.memristorH + 140)
            .attr("fill", "#888")
            .attr("font-size", "12px")
            .attr("font-family", "Rajdhani")
            .attr("text-anchor", "middle")
            .attr("opacity", 0)
            .text(`The wider the channel (higher weight), the more signal passes through!`);
        
        explanationText.transition().delay(200).duration(500).attr("opacity", 1);
        
        log(`Inference complete: ${input} √ó ${state.weight.toFixed(2)} = ${result.toFixed(1)}`, "success");
        
        // Cleanup after animation
        setTimeout(() => {
            inferenceRunning = false;
        }, 2000);
    }

    // Initialize
    init();

</script>
</body>
</html>
