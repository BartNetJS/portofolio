<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Memristor training → weerstand → inference (mini-demo's)</title>
  <style>
    :root{
      --bg:#070A12; --card:#0E1630; --card2:#0B1226;
      --text:#EAF2FF; --muted:#9EB1D6;
      --a:#18E2B8; --b:#6D4BFF; --warn:#FF4FB8; --ion:#FFB020;
      --grid:#1A2A57; --line:#233870;
      --shadow: 0 20px 50px rgba(0,0,0,.35);
      --r:18px;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }
    body{ margin:0; background:radial-gradient(1200px 600px at 20% 0%, #1c0f3a 0%, var(--bg) 55%);
      color:var(--text); padding-bottom:120px; }
    header{ padding:26px 22px 10px; }
    h1{ margin:0 0 6px; font-size:28px; letter-spacing:.2px; }
    p{ margin:0; color:var(--muted); line-height:1.45; }
    .wrap{ padding:18px 22px 28px; display:grid; gap:16px; grid-template-columns: repeat(3, minmax(260px, 1fr)); }
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.01));
      border:1px solid rgba(255,255,255,.08);
      border-radius:var(--r);
      box-shadow:var(--shadow);
      padding:14px 14px 12px;
      min-height: 360px;
      position:relative;
      overflow:hidden;
    }
    .card h2{ margin:2px 0 6px; font-size:16px; }
    .sub{ color:var(--muted); font-size:12.5px; margin-bottom:10px; }
    .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    button{
      background:transparent;
      color:var(--text);
      border:1px solid rgba(255,255,255,.18);
      border-radius:999px;
      padding:8px 12px;
      cursor:pointer;
      font-weight:600;
    }
    button.primary{ border-color: rgba(24,226,184,.75); box-shadow:0 0 0 2px rgba(24,226,184,.08) inset; }
    button.mag{ border-color: rgba(255,79,184,.75); box-shadow:0 0 0 2px rgba(255,79,184,.08) inset; }
    button:active{ transform: translateY(1px); }
    .pill{ padding:6px 10px; border-radius:999px; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.08); font-size:12px; color:var(--muted); }
    .kv{ display:grid; grid-template-columns: 1fr auto; gap:8px 10px; margin-top:10px; }
    .kv div{ font-size:12.5px; color:var(--muted); }
    .kv strong{ color:var(--text); font-weight:700; font-size:12.5px; }
    canvas{ width:100%; height:150px; background:rgba(4,8,20,.45); border:1px solid rgba(255,255,255,.08); border-radius:14px; }
    .barWrap{
      margin-top:10px;
      border-radius:14px; overflow:hidden;
      border:1px solid rgba(255,255,255,.08);
      background:rgba(4,8,20,.45);
    }
    .bar{
      height:28px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      position:relative;
    }
    .doped{ background:linear-gradient(90deg, rgba(24,226,184,.35), rgba(24,226,184,.18)); }
    .undoped{ background:linear-gradient(90deg, rgba(109,75,255,.18), rgba(109,75,255,.10)); }
    .boundary{
      position:absolute; top:0; bottom:0;
      width:2px; background:rgba(255,255,255,.75);
      box-shadow:0 0 0 3px rgba(255,255,255,.08);
      left:50%;
    }
    .legend{ display:flex; gap:10px; flex-wrap:wrap; margin-top:8px; font-size:12px; color:var(--muted); }
    .dot{ width:10px; height:10px; border-radius:3px; display:inline-block; margin-right:6px; vertical-align:-1px; }
    .mono{ font-variant-numeric: tabular-nums; font-feature-settings:"tnum" 1; }
    .small{ font-size:12px; color:var(--muted); margin-top:10px; line-height:1.35; }
    .hr{ height:1px; background:rgba(255,255,255,.08); margin:10px 0; }
    .slider{ width: 100%; }
    @media (max-width: 980px){ .wrap{ grid-template-columns: 1fr; } }
  </style>
</head>
<body>
<header>
  <h1>Memristor: training (ion drift) → weerstandstoestand → inference (read)</h1>
  <p>Didactische simulaties: interne toestand <span class="mono">x ∈ [0..1]</span> verschuift tijdens training (ionen bewegen), en bepaalt conductantie <span class="mono">G(x)</span>. Inference gebruikt kleine spanning en “leest” zonder de toestand te veranderen (idealiserend model).</p>
</header>

<div class="wrap">
  <!-- DEMO 1 -->
  <section class="card" id="demo1">
    <h2>1) Potentiation vs Depression + veilige read</h2>
    <div class="sub">Trainpulsen veranderen <span class="mono">x</span> stapje-voor-stapje. Read gebruikt kleine spanning en verandert <span class="mono">x</span> niet.</div>

    <div class="row">
      <button class="primary" id="d1_plus">Train +V (meer G, minder R)</button>
      <button class="mag" id="d1_minus">Train −V (minder G, meer R)</button>
      <button id="d1_read">Read (klein V)</button>
      <span class="pill mono" id="d1_last">laatste: —</span>
    </div>

    <div class="barWrap">
      <div class="bar">
        <div class="doped"></div>
        <div class="undoped"></div>
        <div class="boundary" id="d1_boundary"></div>
      </div>
    </div>
    <div class="legend">
      <span><span class="dot" style="background:rgba(24,226,184,.55)"></span>gedopeerd (lage R / hoge G)</span>
      <span><span class="dot" style="background:rgba(109,75,255,.55)"></span>ongedopeerd (hoge R / lage G)</span>
      <span><span class="dot" style="background:rgba(255,255,255,.75)"></span>grenspositie = toestand <span class="mono">x</span></span>
    </div>

    <div class="kv mono">
      <div>toestand x</div><strong id="d1_x">0.50</strong>
      <div>conductantie G</div><strong id="d1_g">—</strong>
      <div>weerstand R = 1/G</div><strong id="d1_r">—</strong>
      <div>read-stroom I = Vread·G</div><strong id="d1_i">—</strong>
    </div>

    <div class="hr"></div>
    <canvas id="d1_plot" width="800" height="260"></canvas>
    <div class="small">
      <b>Wat je hier “voelt”:</b> tijdens training verschuift de grens → <span class="mono">G</span> verandert analoog (dus niet enkel 0/1). Inference meet een stroom die direct afhangt van die opgeslagen <span class="mono">G</span>.
    </div>
  </section>

  <!-- DEMO 2 -->
  <section class="card" id="demo2">
    <h2>2) Pulstrein + saturatie (analoge ladder)</h2>
    <div class="sub">Laat zien dat veel kleine pulses een “trap” vormen en uiteindelijk satureren tegen 0 of 1.</div>

    <div class="row">
      <button class="primary" id="d2_run_pos">+ pulses (20x)</button>
      <button class="mag" id="d2_run_neg">− pulses (20x)</button>
      <button id="d2_reset">Reset</button>
      <span class="pill mono" id="d2_mode">mode: —</span>
    </div>

    <div class="barWrap" style="margin-top:12px;">
      <div class="bar">
        <div class="doped"></div>
        <div class="undoped"></div>
        <div class="boundary" id="d2_boundary"></div>
      </div>
    </div>

    <div class="row" style="margin-top:10px;">
      <span class="pill mono">x: <span id="d2_x">0.50</span></span>
      <span class="pill mono">R: <span id="d2_r">—</span></span>
      <span class="pill mono">levels gezien: <span id="d2_levels">—</span></span>
    </div>

    <div class="hr"></div>
    <canvas id="d2_plot" width="800" height="260"></canvas>
    <div class="small">
      <b>Blog-zin die hierbij past:</b> “Training is het herhaald aanleggen van pulsen die de fysieke toestand verschuiven; de opgeslagen analog state vertaalt zich naar een continu bereik aan weerstanden.”
    </div>
  </section>

  <!-- DEMO 3 -->
  <section class="card" id="demo3">
    <h2>3) Eén memristor als “gewicht” in een mini-learner</h2>
    <div class="sub">We koppelen <span class="mono">w</span> aan de fysieke toestand: <span class="mono">w = wmin + x·(wmax-wmin)</span>. Training doet: <span class="mono">w ← w + η·(target - y)·input</span> (vereenvoudigd).</div>

    <div class="row">
      <span class="pill mono">input</span>
      <input class="slider" id="d3_in" type="range" min="0" max="1" step="0.01" value="0.70"/>
      <span class="pill mono" id="d3_inv">0.70</span>
    </div>

    <div class="row" style="margin-top:8px;">
      <span class="pill mono">target</span>
      <input class="slider" id="d3_t" type="range" min="0" max="1" step="0.01" value="0.80"/>
      <span class="pill mono" id="d3_tv">0.80</span>
    </div>

    <div class="row" style="margin-top:10px;">
      <button class="primary" id="d3_step">Train step</button>
      <button id="d3_read">Inference read</button>
      <button id="d3_reset">Reset</button>
      <span class="pill mono" id="d3_msg">—</span>
    </div>

    <div class="barWrap" style="margin-top:12px;">
      <div class="bar">
        <div class="doped"></div>
        <div class="undoped"></div>
        <div class="boundary" id="d3_boundary"></div>
      </div>
    </div>

    <div class="kv mono">
      <div>gewicht w (uit x)</div><strong id="d3_w">—</strong>
      <div>output y = w·input</div><strong id="d3_y">—</strong>
      <div>error = target - y</div><strong id="d3_e">—</strong>
      <div>toestand x</div><strong id="d3_x">0.50</strong>
    </div>

    <div class="hr"></div>
    <canvas id="d3_plot" width="800" height="260"></canvas>
    <div class="small">
      <b>Waarom dit inference verklaart:</b> inference hoeft niet “ionen te begrijpen”. Het ziet enkel een conductantie/weerstand die als gewicht werkt in een berekening (stroom-som, multiply-accumulate).
    </div>
  </section>
</div>

<script>
/* =========================
   Simpele memristor-model
   =========================
   x in [0..1] ~ grens/gedopeerde fractie
   G(x) = Goff + x*(Gon-Goff)  (lineair, didactisch)
   R = 1/G
   Training pulse: x += k * sign(V) * f(|V|)  (met saturatie)
   Read: kleine spanning; x verandert niet (idealiserend)
*/
function clamp01(v){ return Math.max(0, Math.min(1, v)); }

function makeMemristor(opts){
  const m = {
    x: opts?.x ?? 0.5,
    Gon: opts?.Gon ?? 1/800,   // Siemens (≈ 800Ω)
    Goff: opts?.Goff ?? 1/20000, // Siemens (≈ 20kΩ)
    k: opts?.k ?? 0.03,       // stapgrootte per pulse (didactisch)
    vth: opts?.vth ?? 0.35,   // drempel: onder dit "gebeurt niets"
    history: [],
    push(){
      const G = this.Goff + this.x * (this.Gon - this.Goff);
      const R = 1 / G;
      this.history.push({x:this.x, G, R});
      if(this.history.length > 200) this.history.shift();
      return {x:this.x, G, R};
    },
    state(){
      const G = this.Goff + this.x * (this.Gon - this.Goff);
      const R = 1 / G;
      return {x:this.x, G, R};
    },
    trainPulse(V){
      const a = Math.abs(V);
      if(a <= this.vth){
        return {moved:false, reason:"|V| onder drempel"};
      }
      // f(|V|): iets sterker boven drempel, maar gedempt naar randen toe
      const strength = Math.min(1, (a - this.vth) / (1 - this.vth));
      const edgeDamp = 0.3 + 0.7 * (1 - Math.abs(this.x - 0.5)*2); // trager bij randen
      const dx = this.k * Math.sign(V) * strength * edgeDamp;
      this.x = clamp01(this.x + dx);
      return {moved:true, dx};
    },
    read(Vread){
      const {G,R} = this.state();
      const I = Vread * G;
      return {G,R,I, Vread};
    }
  };
  m.push();
  return m;
}

function setBoundary(el, x){
  el.style.left = (x*100).toFixed(2) + "%";
}

function fmt(v, d=2){ return Number(v).toFixed(d); }
function fmtOhm(R){
  if(R >= 1000) return fmt(R/1000,2)+" kΩ";
  return fmt(R,1)+" Ω";
}
function fmtS(G){
  // toon als mS of µS
  const mS = G*1000;
  if(mS >= 1) return fmt(mS,3)+" mS";
  return fmt(G*1e6,1)+" µS";
}
function drawPlot(canvas, series, yKey, yLabel){
  const ctx = canvas.getContext("2d");
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0,0,W,H);

  // grid
  ctx.strokeStyle = "rgba(255,255,255,0.08)";
  ctx.lineWidth = 1;
  for(let i=1;i<6;i++){
    const y = i*H/6;
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
  }

  if(series.length < 2) return;

  const ys = series.map(p=>p[yKey]);
  const yMin = Math.min(...ys), yMax = Math.max(...ys);
  const pad = (yMax - yMin) * 0.12 || 1;
  const a = yMin - pad, b = yMax + pad;

  // axis label
  ctx.fillStyle = "rgba(234,242,255,0.75)";
  ctx.font = "12px ui-sans-serif, system-ui";
  ctx.fillText(yLabel, 10, 18);

  // line
  ctx.strokeStyle = "rgba(24,226,184,0.9)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  for(let i=0;i<series.length;i++){
    const x = i*(W-20)/(series.length-1) + 10;
    const y = H - ((series[i][yKey]-a)/(b-a))*(H-30) - 10;
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();

  // points (last)
  const last = series[series.length-1];
  const lx = (series.length-1)*(W-20)/(series.length-1) + 10;
  const ly = H - ((last[yKey]-a)/(b-a))*(H-30) - 10;
  ctx.fillStyle = "rgba(255,79,184,0.9)";
  ctx.beginPath(); ctx.arc(lx,ly,4,0,Math.PI*2); ctx.fill();
}

// ---------------- DEMO 1 ----------------
const d1 = makeMemristor({x:0.50});
const d1b = document.getElementById("d1_boundary");
const d1x = document.getElementById("d1_x");
const d1g = document.getElementById("d1_g");
const d1r = document.getElementById("d1_r");
const d1i = document.getElementById("d1_i");
const d1last = document.getElementById("d1_last");
const d1plot = document.getElementById("d1_plot");

function refreshD1(){
  const {x,G,R} = d1.state();
  setBoundary(d1b, x);
  d1x.textContent = fmt(x,2);
  d1g.textContent = fmtS(G);
  d1r.textContent = fmtOhm(R);
  const rd = d1.read(0.10);
  d1i.textContent = fmt(rd.I*1e6,1) + " µA @ Vread=0.10V";
  drawPlot(d1plot, d1.history, "R", "R over stappen (train + read events)");
}
refreshD1();

document.getElementById("d1_plus").onclick = () => {
  const r = d1.trainPulse(+1.0);
  d1.push();
  d1last.textContent = r.moved ? "train +V, dx="+fmt(r.dx,3) : "train +V (geen drift)";
  refreshD1();
};
document.getElementById("d1_minus").onclick = () => {
  const r = d1.trainPulse(-1.0);
  d1.push();
  d1last.textContent = r.moved ? "train −V, dx="+fmt(r.dx,3) : "train −V (geen drift)";
  refreshD1();
};
document.getElementById("d1_read").onclick = () => {
  // read verandert x niet; we loggen wel voor de plot
  d1.push();
  d1last.textContent = "read @ klein V (x blijft gelijk)";
  refreshD1();
};

// ---------------- DEMO 2 ----------------
const d2 = makeMemristor({x:0.50, k:0.025});
const d2b = document.getElementById("d2_boundary");
const d2x = document.getElementById("d2_x");
const d2r = document.getElementById("d2_r");
const d2levels = document.getElementById("d2_levels");
const d2mode = document.getElementById("d2_mode");
const d2plot = document.getElementById("d2_plot");

function refreshD2(){
  const {x,R} = d2.state();
  setBoundary(d2b, x);
  d2x.textContent = fmt(x,2);
  d2r.textContent = fmtOhm(R);
  // hoeveel unieke x-levels (afgerond) hebben we geraakt
  const uniq = new Set(d2.history.map(p=>fmt(p.x,2)));
  d2levels.textContent = uniq.size;
  drawPlot(d2plot, d2.history, "x", "x (analoge toestand) over pulsen");
}
refreshD2();

function runPulses(sign){
  d2mode.textContent = sign>0 ? "mode: + pulstrein" : "mode: − pulstrein";
  for(let i=0;i<20;i++){
    d2.trainPulse(sign*1.0);
    d2.push();
  }
  refreshD2();
}
document.getElementById("d2_run_pos").onclick = ()=>runPulses(+1);
document.getElementById("d2_run_neg").onclick = ()=>runPulses(-1);
document.getElementById("d2_reset").onclick = ()=>{
  d2.x = 0.50;
  d2.history = [];
  d2.push();
  d2mode.textContent = "mode: —";
  refreshD2();
};

// ---------------- DEMO 3 ----------------
const d3 = makeMemristor({x:0.50, k:0.018});
const d3b = document.getElementById("d3_boundary");
const d3_in = document.getElementById("d3_in");
const d3_t = document.getElementById("d3_t");
const d3_inv = document.getElementById("d3_inv");
const d3_tv = document.getElementById("d3_tv");
const d3_w = document.getElementById("d3_w");
const d3_y = document.getElementById("d3_y");
const d3_e = document.getElementById("d3_e");
const d3_x = document.getElementById("d3_x");
const d3_msg = document.getElementById("d3_msg");
const d3plot = document.getElementById("d3_plot");

// gewicht mapping
const wMin = -1.0, wMax = 3.0;
const eta = 0.35; // learning rate (didactisch)

function calcW(){
  return wMin + d3.x*(wMax - wMin);
}
function refreshD3(){
  const x = d3.x;
  const w = calcW();
  const inp = Number(d3_in.value);
  const tgt = Number(d3_t.value);
  const y = w * inp;
  const e = tgt - y;

  setBoundary(d3b, x);
  d3_x.textContent = fmt(x,2);
  d3_w.textContent = fmt(w,3);
  d3_y.textContent = fmt(y,3);
  d3_e.textContent = fmt(e,3);

  // plot: error over time (we gebruiken R als proxy? nee, we loggen custom)
  // We tekenen x-history (want dat is fysiek) maar label als "x tijdens learning"
  drawPlot(d3plot, d3.history, "x", "x (fysieke toestand) tijdens learning steps");
}
function syncSliders(){
  d3_inv.textContent = fmt(d3_in.value,2);
  d3_tv.textContent = fmt(d3_t.value,2);
  refreshD3();
}
d3_in.oninput = syncSliders;
d3_t.oninput = syncSliders;

document.getElementById("d3_step").onclick = ()=>{
  const inp = Number(d3_in.value);
  const tgt = Number(d3_t.value);

  const w = calcW();
  const y = w * inp;
  const e = tgt - y;

  // gradient step: w <- w + eta*e*inp
  const wNew = w + eta * e * inp;

  // map back to x (clamp)
  const xNew = clamp01((wNew - wMin)/(wMax - wMin));

  // fysieke training pulse richting: sign bepaalt +V of -V
  const sign = Math.sign(xNew - d3.x) || 1;
  // doe meerdere kleine pulsen om naar xNew te bewegen
  let steps = 0;
  while(Math.abs(d3.x - xNew) > 0.002 && steps < 20){
    d3.trainPulse(sign * 1.0);
    d3.push();
    steps++;
  }
  d3_msg.textContent = "train: error→gewicht→ion drift ("+steps+" pulses)";
  refreshD3();
};

document.getElementById("d3_read").onclick = ()=>{
  // inference: read (klein V) en toon output y, zonder x te veranderen
  d3.push();
  d3_msg.textContent = "inference read: x blijft gelijk, y gebruikt opgeslagen w";
  refreshD3();
};

document.getElementById("d3_reset").onclick = ()=>{
  d3.x = 0.50;
  d3.history = [];
  d3.push();
  d3_msg.textContent = "reset";
  refreshD3();
};

syncSliders();
</script>
<script src="../shared/bottom-nav.js" data-nav-active="blogs"></script>
</body>
</html>
