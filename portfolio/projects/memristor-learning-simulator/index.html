<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-8FSDD3KHS3"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-8FSDD3KHS3');
  </script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Interactive Memristor Learning Simulator</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&family=Rajdhani:wght@400;500;600&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js"></script>
  <style>
    :root {
      --bg: #0a0e17;
      --panel: #121a2e;
      --doped: #00f5ff;
      --undoped: #2a1a4a;
      --ion: #ffaa00;
      --current: #00ff88;
      --accent-pos: #00ff88;
      --accent-neg: #ff00aa;
      --text: #cdd6f4;
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      font-family: 'Rajdhani', 'Segoe UI', Tahoma, sans-serif;
      background: radial-gradient(circle at 20% 20%, rgba(0,255,136,0.08), transparent 25%),
                  radial-gradient(circle at 80% 0%, rgba(255,0,170,0.08), transparent 25%),
                  var(--bg);
      color: var(--text);
      min-height: 100vh;
    }

    a.back-link {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      margin: 24px;
      color: #60a5fa;
      text-decoration: none;
      font-weight: 600;
    }

    header {
      text-align: center;
      padding: 10px 20px 30px;
    }
    h1 {
      font-family: 'Orbitron', sans-serif;
      letter-spacing: 1px;
      color: #00f5ff;
      margin-bottom: 10px;
    }
    .subtitle { color: #9fb0d7; }

    .layout {
      display: grid;
      grid-template-columns: 380px 1fr;
      gap: 16px;
      padding: 0 20px 30px;
      max-width: 1400px;
      margin: 0 auto;
    }
    .panel {
      background: var(--panel);
      border: 1px solid #1f2b45;
      border-radius: 16px;
      padding: 18px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    }
    .panel h3 { margin-top: 0; color: #00f5ff; font-family: 'Orbitron', sans-serif; letter-spacing: 0.5px; }
    label { display: block; margin: 10px 0 4px; font-weight: 600; }
    select, input[type="number"], input[type="text"] {
      width: 100%;
      padding: 10px;
      background: #0c1323;
      border: 1px solid #1f2b45;
      border-radius: 10px;
      color: var(--text);
      font-family: inherit;
    }
    .mode-toggle { display: flex; gap: 10px; align-items: center; margin: 10px 0 16px; }
    .mode-toggle label { margin: 0; display: flex; align-items: center; gap: 6px; font-weight: 500; }

    .btn {
      width: 100%;
      padding: 12px;
      border: none;
      border-radius: 12px;
      margin-top: 10px;
      font-weight: 700;
      letter-spacing: 0.3px;
      color: #0a0e17;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      background: linear-gradient(135deg, #00f5ff, #00ff88);
    }
    .btn.secondary { background: linear-gradient(135deg, #2a1a4a, #50276a); color: #f6e7ff; }
    .btn:hover { transform: translateY(-2px); box-shadow: 0 10px 25px rgba(0,255,136,0.25); }

    .training-list {
      margin-top: 10px;
      border: 1px solid #1f2b45;
      border-radius: 12px;
      padding: 10px;
      background: #0c1323;
      max-height: 190px;
      overflow-y: auto;
    }
    .training-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 10px;
      border-bottom: 1px solid #1f2b45;
      font-weight: 600;
      color: #e5edff;
    }
    .training-item:last-child { border-bottom: none; }
    .training-item.active { background: rgba(0,255,136,0.08); border-radius: 8px; }
    .badge { padding: 2px 8px; border-radius: 12px; font-size: 12px; }
    .badge.success { background: rgba(0,255,136,0.18); color: #00ff88; }

    .memristor-card { grid-column: span 2; }
    .memristor-wrapper { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    .svg-shell { background: #0c1323; border: 1px solid #1f2b45; border-radius: 12px; padding: 12px; }

    #memristor-svg { width: 100%; height: 320px; }

    .status-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-top: 12px; }
    .status-box { background: #0c1323; padding: 10px; border-radius: 10px; border: 1px solid #1f2b45; }
    .status-label { color: #9fb0d7; font-size: 13px; }
    .status-value { font-size: 20px; font-family: 'Orbitron', sans-serif; color: #00ff88; }

    .compute-area { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-top: 16px; }
    .equation { font-family: 'Orbitron', sans-serif; font-size: 18px; line-height: 1.4; }
    .equation span { color: #00f5ff; }
    .log { max-height: 200px; overflow-y: auto; background: #0c1323; border: 1px solid #1f2b45; padding: 12px; border-radius: 12px; font-family: 'Rajdhani'; font-size: 14px; }
    .log-line { margin-bottom: 6px; color: #d0dcff; }
    .highlight { color: #00ff88; }

    .computation-visual { position: relative; height: 140px; background: #0c1323; border: 1px solid #1f2b45; border-radius: 12px; overflow: hidden; }
    .node { position: absolute; width: 80px; height: 80px; border-radius: 16px; background: #111b30; border: 1px solid #1f2b45; display: flex; align-items: center; justify-content: center; color: #00f5ff; font-family: 'Orbitron'; }
    .node.input { left: 20px; top: 30px; }
    .node.mem { left: calc(50% - 40px); top: 30px; background: linear-gradient(135deg, #00f5ff33, #2a1a4a88); color: #ffaa00; }
    .node.output { right: 20px; top: 30px; color: #00ff88; }
    .flow { position: absolute; top: 70px; left: 100px; right: 100px; height: 4px; background: linear-gradient(90deg, rgba(0,255,136,0.2), rgba(0,255,136,0.8)); border-radius: 4px; }
    .current-dot { position: absolute; top: 63px; width: 12px; height: 12px; border-radius: 50%; background: var(--current); box-shadow: 0 0 10px var(--current); opacity: 0; }

    @media (max-width: 1100px) {
      .layout { grid-template-columns: 1fr; }
      .memristor-wrapper { grid-template-columns: 1fr; }
      .memristor-card { grid-column: span 1; }
      .compute-area { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <a class="back-link" href="/portfolio/">← Back to Portofolios</a>
  <header>
    <h1>Memristor Learning Simulator</h1>
    <p class="subtitle">Watch ions move during training and current flow during inference as the device learns arithmetic patterns.</p>
  </header>

  <div class="layout">
    <div class="panel">
      <h3>Controls</h3>
      <label for="operation">Operation</label>
      <select id="operation">
        <option value="multiply">Multiplication (×)</option>
        <option value="divide">Division (÷)</option>
        <option value="add">Addition (+)</option>
        <option value="subtract">Subtraction (−)</option>
        <option value="power">Power (^)</option>
      </select>
      <label for="operand">Target parameter (e.g., multiplier, divisor, addend, exponent)</label>
      <input type="number" id="operand" value="2" />

      <div class="mode-toggle">
        <label><input type="radio" name="mode" value="train" checked /> Training</label>
        <label><input type="radio" name="mode" value="inference" /> Inference</label>
      </div>

      <div class="training-list" id="training-list"></div>

      <div style="display:flex; gap:8px; margin-top:8px;">
        <input type="number" id="new-input" placeholder="Add input example" />
        <button class="btn secondary" style="width:160px;" id="add-example">+ Add Example</button>
      </div>
      <button class="btn secondary" id="auto-generate">Auto-Generate Examples</button>
      <button class="btn" id="train-btn">Train Network</button>

      <h3 style="margin-top:20px;">Test Input</h3>
      <input type="number" id="test-input" value="7" />
      <button class="btn" id="compute-btn">Compute with Learned Weight</button>
      <div style="margin-top:10px; font-size:18px; color:#00ff88;">Result: <span id="result-value">—</span></div>
    </div>

    <div class="panel memristor-card">
      <h3>Physical Memristor View</h3>
      <div class="memristor-wrapper">
        <div class="svg-shell">
          <svg id="memristor-svg" viewBox="0 0 640 320"></svg>
        </div>
        <div>
          <p style="color:#9fb0d7;">Training mode animates ion drift and boundary shifts. Inference mode freezes ions and visualizes current flowing through the learned conductance.</p>
          <div class="status-grid">
            <div class="status-box"><div class="status-label">Weight (W)</div><div class="status-value" id="weight-display">1.00</div></div>
            <div class="status-box"><div class="status-label">Memristance (Ω)</div><div class="status-value" id="resistance-display">—</div></div>
            <div class="status-box"><div class="status-label">Mode</div><div class="status-value" id="mode-display">Training</div></div>
          </div>
          <div class="status-grid" style="margin-top:10px;">
            <div class="status-box"><div class="status-label">Boundary</div><div class="status-value" id="boundary-display">—</div></div>
            <div class="status-box"><div class="status-label">Last Error</div><div class="status-value" id="error-display">—</div></div>
            <div class="status-box"><div class="status-label">Learning Rate</div><div class="status-value" id="lr-display">0.05</div></div>
          </div>
        </div>
      </div>

      <div class="compute-area">
        <div class="panel" style="background:#0c1323;">
          <h3>Computation</h3>
          <div class="computation-visual" id="computation-visual">
            <div class="node input" id="input-node">Input</div>
            <div class="flow"></div>
            <div class="node mem" id="mem-node">W</div>
            <div class="node output" id="output-node">Output</div>
          </div>
          <div class="equation" id="equation-block" style="margin-top:10px;"></div>
        </div>
        <div class="panel" style="background:#0c1323;">
          <h3>Training Log</h3>
          <div class="log" id="log"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const svg = d3.select('#memristor-svg');
    const width = 640, height = 320;
    const channel = { x: 80, y: 80, width: 480, height: 120 };
    const electrodes = svg.append('g');
    const channelGroup = svg.append('g');
    const ionsGroup = svg.append('g');
    const boundaryGroup = svg.append('g');

    let weight = 1.0;
    let learningRate = 0.05;
    let trainingData = [1,3,5];
    let mode = 'train';
    let operation = 'multiply';
    let operand = 2;
    let ions = [];
    let inferenceTimer;

    const minWeight = -2;
    const maxWeight = 4;

    function weightToFraction(w){
      const clamped = Math.max(minWeight, Math.min(maxWeight, w));
      return 0.08 + 0.84 * ((clamped - minWeight)/(maxWeight - minWeight));
    }

    function computeResistance(fraction){
      const ron = 1000; // low resistance
      const roff = 12000; // high resistance
      return Math.round(ron * fraction + roff * (1 - fraction));
    }

    function createMemristor(){
      svg.append('defs')
        .append('linearGradient')
        .attr('id','dopedGradient')
        .attr('x1','0%').attr('x2','100%')
        .attr('y1','0%').attr('y2','0%')
        .selectAll('stop')
        .data([
          {offset:'0%', color:'#00f5ff66'},
          {offset:'100%', color:'#00f5ff'}
        ])
        .enter()
        .append('stop')
        .attr('offset', d=>d.offset)
        .attr('stop-color', d=>d.color);

      electrodes.append('rect')
        .attr('x', channel.x)
        .attr('y', channel.y - 40)
        .attr('width', channel.width)
        .attr('height', 20)
        .attr('rx', 8)
        .attr('fill', '#1f2b45');

      electrodes.append('rect')
        .attr('x', channel.x)
        .attr('y', channel.y + channel.height + 20)
        .attr('width', channel.width)
        .attr('height', 20)
        .attr('rx', 8)
        .attr('fill', '#1f2b45');

      electrodes.append('text')
        .attr('id','top-voltage')
        .attr('x', channel.x - 30)
        .attr('y', channel.y - 25)
        .attr('fill', '#00ff88')
        .attr('font-size', 14)
        .attr('font-family','Orbitron')
        .text('+V');
      electrodes.append('text')
        .attr('id','bottom-voltage')
        .attr('x', channel.x - 30)
        .attr('y', channel.y + channel.height + 55)
        .attr('fill', '#9fb0d7')
        .attr('font-size', 14)
        .attr('font-family','Orbitron')
        .text('GND');

      channelGroup.append('rect')
        .attr('x', channel.x)
        .attr('y', channel.y)
        .attr('width', channel.width)
        .attr('height', channel.height)
        .attr('fill', '#0c1323')
        .attr('stroke', '#1f2b45')
        .attr('rx', 10);

      channelGroup.append('rect')
        .attr('id','doped-region')
        .attr('x', channel.x)
        .attr('y', channel.y)
        .attr('width', channel.width * weightToFraction(weight))
        .attr('height', channel.height)
        .attr('fill', 'url(#dopedGradient)');

      channelGroup.append('rect')
        .attr('id','undoped-region')
        .attr('x', channel.x + channel.width * weightToFraction(weight))
        .attr('y', channel.y)
        .attr('width', channel.width * (1 - weightToFraction(weight)))
        .attr('height', channel.height)
        .attr('fill', varUndoped());

      boundaryGroup.append('line')
        .attr('id','boundary-line')
        .attr('x1', channel.x + channel.width * weightToFraction(weight))
        .attr('x2', channel.x + channel.width * weightToFraction(weight))
        .attr('y1', channel.y)
        .attr('y2', channel.y + channel.height)
        .attr('stroke', '#ffaa00')
        .attr('stroke-width', 3)
        .attr('stroke-dasharray', '6,4');

      createIons();
    }

    function varUndoped(){ return '#2a1a4a'; }

    function createIons(){
      ions = d3.range(22).map(()=>({
        x: channel.x + Math.random()*channel.width,
        y: channel.y + 10 + Math.random()*(channel.height-20)
      }));
      const ionSel = ionsGroup.selectAll('circle').data(ions);
      ionSel.enter().append('circle')
        .attr('r', 6)
        .attr('fill', varUndoped())
        .attr('stroke', '#ffaa00')
        .attr('stroke-width', 1.5)
        .attr('cx', d=>d.x)
        .attr('cy', d=>d.y)
        .attr('opacity',0.9)
        .style('filter','drop-shadow(0 0 8px #ffaa00)');
      updateIonColors();
    }

    function updateIonColors(){
      const boundaryX = channel.x + channel.width * weightToFraction(weight);
      ionsGroup.selectAll('circle')
        .transition().duration(300)
        .attr('fill', d=> d.x <= boundaryX ? '#ffaa00' : '#2a1a4a')
        .attr('stroke', d=> d.x <= boundaryX ? '#ffd166' : '#7040a0');
    }

    function updateMemristorVisual(weightChange=0){
      const fraction = weightToFraction(weight);
      const boundaryX = channel.x + channel.width * fraction;
      svg.select('#doped-region')
        .transition().duration(500)
        .attr('width', channel.width * fraction);
      svg.select('#undoped-region')
        .transition().duration(500)
        .attr('x', boundaryX)
        .attr('width', channel.width * (1-fraction));
      svg.select('#boundary-line')
        .transition().duration(500)
        .attr('x1', boundaryX)
        .attr('x2', boundaryX);

      ions.forEach(ion => {
        ion.x += weightChange * 120;
        ion.x = Math.max(channel.x, Math.min(channel.x + channel.width, ion.x));
      });
      ionsGroup.selectAll('circle')
        .data(ions)
        .transition().duration(500)
        .attr('cx', d=>d.x);
      updateIonColors();

      d3.select('#weight-display').text(weight.toFixed(3));
      d3.select('#resistance-display').text(computeResistance(fraction).toLocaleString());
      d3.select('#boundary-display').text((fraction*100).toFixed(1)+'%');
    }

    function logLine(text){
      const log = d3.select('#log');
      log.append('div').attr('class','log-line').html(text);
      const logNode = log.node();
      logNode.scrollTop = logNode.scrollHeight;
    }

    function renderTrainingList(activeIndex=null){
      const list = d3.select('#training-list');
      const items = list.selectAll('.training-item').data(trainingData);
      const enter = items.enter().append('div').attr('class','training-item');
      enter.append('div').attr('class','text');
      enter.append('div').attr('class','badge success').text('✓');

      items.merge(enter)
        .classed('active', (d,i)=> i===activeIndex)
        .select('.text')
        .text(d=> `${d} ${symbolForOperation(operation)} ${operand} = ${formatExpected(d)}`);

      items.exit().remove();
    }

    function symbolForOperation(op){
      return {multiply:'×', divide:'÷', add:'＋', subtract:'−', power:'^'}[op] || '×';
    }

    function formatExpected(input){
      return computeExpected(input).toFixed(2).replace(/\.00$/,'');
    }

    function computeExpected(input){
      const val = Number(operand);
      switch(operation){
        case 'multiply': return input * val;
        case 'divide': return input / val;
        case 'add': return input + val;
        case 'subtract': return input - val;
        case 'power': return Math.pow(input, val);
        default: return input * val;
      }
    }

    function predict(input, w){
      switch(operation){
        case 'multiply':
        case 'divide':
          return input * w;
        case 'add':
          return input + w;
        case 'subtract':
          return input - w;
        case 'power':
          return Math.pow(input, w);
        default:
          return input * w;
      }
    }

    function updateWeight(input){
      const expected = computeExpected(input);
      const predicted = predict(input, weight);
      const error = expected - predicted;
      const before = weight;
      let gradient = 0;
      switch(operation){
        case 'multiply':
        case 'divide':
          gradient = error * input;
          weight += learningRate * gradient;
          break;
        case 'add':
          weight += learningRate * error;
          break;
        case 'subtract':
          weight += learningRate * error * -1; // predicted decreases as weight grows
          break;
        case 'power':
          const derivative = predicted * Math.log(Math.max(input, 1e-6));
          weight += learningRate * error * derivative * 0.001; // scaled for stability
          break;
      }
      weight = Math.max(minWeight, Math.min(maxWeight, weight));
      return { error, predicted, expected, weightChange: weight - before };
    }

    async function trainNetwork(){
      if(mode !== 'train') {
        d3.select('input[name="mode"][value="train"]').property('checked', true);
        switchMode('train');
      }
      clearInterval(inferenceTimer);
      logLine('<span class="highlight">Starting training...</span>');
      let epoch = 1;
      for(; epoch <= 25; epoch++){
        let totalError = 0;
        for(let i=0;i<trainingData.length;i++){
          renderTrainingList(i);
          const {error, predicted, expected, weightChange} = updateWeight(trainingData[i]);
          totalError += Math.abs(error);
          flashVoltage(weightChange);
          updateMemristorVisual(weightChange);
          updateIonColors();
          d3.select('#error-display').text(error.toFixed(3));
          logLine(`[Epoch ${epoch}] ${trainingData[i]}${symbolForOperation(operation)}${operand}: W → ${weight.toFixed(3)}, error=${error.toFixed(3)}`);
          await delay(600);
        }
        renderTrainingList();
        if(totalError / trainingData.length < 0.02){
          logLine(`<span class="highlight">Converged in epoch ${epoch}! W=${weight.toFixed(3)}</span>`);
          break;
        }
      }
      logLine('<span class="highlight">Training complete. Switch to inference and test new numbers.</span>');
    }

    function flashVoltage(change){
      const pos = change >=0;
      d3.select('#top-voltage')
        .transition().duration(200)
        .attr('fill', pos ? '#00ff88' : '#ff00aa')
        .attr('font-size', 16)
        .transition().duration(200)
        .attr('font-size', 14);
      d3.select('#bottom-voltage')
        .transition().duration(200)
        .attr('fill', pos ? '#9fb0d7' : '#ffaaee')
        .transition().duration(200)
        .attr('fill', '#9fb0d7');
    }

    function delay(ms){ return new Promise(res=>setTimeout(res, ms)); }

    function switchMode(next){
      mode = next;
      d3.select('#mode-display').text(mode === 'train' ? 'Training' : 'Inference');
      if(mode === 'inference'){
        startIdleCurrent();
      } else {
        clearInterval(inferenceTimer);
        stopCurrentDots();
      }
    }

    function startIdleCurrent(){
      stopCurrentDots();
      inferenceTimer = setInterval(()=> animateCurrentFlow(0,0,true), 1600);
    }

    function stopCurrentDots(){
      d3.selectAll('.current-dot').remove();
    }

    function animateCurrentFlow(inputVal, outputVal, subtle=false){
      const flowArea = document.querySelector('.flow');
      if(!flowArea) return;
      const flowRect = flowArea.getBoundingClientRect();
      const containerRect = document.querySelector('#computation-visual').getBoundingClientRect();
      const startX = flowRect.left - containerRect.left;
      const width = flowRect.width;
      const dot = d3.select('#computation-visual')
        .append('div')
        .attr('class','current-dot')
        .style('left', startX + 'px')
        .style('opacity', subtle?0.3:1);
      dot.transition().duration(900)
        .style('left', (startX + width - 12)+'px')
        .style('opacity', subtle?0.2:1)
        .on('end',()=> dot.remove());

      d3.select('#input-node').text(inputVal === 0 && subtle ? 'Idle' : inputVal);
      d3.select('#mem-node').text('W=' + weight.toFixed(2));
      d3.select('#output-node').text(subtle? 'Ready' : outputVal.toFixed(2));
    }

    function updateEquation(inputVal, result){
      const symbol = symbolForOperation(operation);
      const eq = `I = ${inputVal} ${symbol} ${weight.toFixed(3)} = <span class="highlight">${result.toFixed(3)}</span>`;
      d3.select('#equation-block').html(eq);
    }

    function computeInference(){
      const inputVal = Number(document.getElementById('test-input').value || 0);
      const result = predict(inputVal, weight);
      document.getElementById('result-value').textContent = result.toFixed(3).replace(/\.000$/,'');
      updateEquation(inputVal, result);
      animateCurrentFlow(inputVal, result);
      logLine(`Inference: ${inputVal} ${symbolForOperation(operation)} ${operand} → ${result.toFixed(3)} using W=${weight.toFixed(3)}`);
    }

    // Event wiring
    document.getElementById('operation').addEventListener('change', e=>{
      operation = e.target.value;
      weight = operation==='divide' ? 0.5 : 1.0;
      renderTrainingList();
      updateMemristorVisual();
    });
    document.getElementById('operand').addEventListener('input', e=>{
      operand = Number(e.target.value) || 1;
      renderTrainingList();
    });
    document.getElementById('train-btn').addEventListener('click', trainNetwork);
    document.getElementById('compute-btn').addEventListener('click', ()=>{ switchMode('inference'); document.querySelector('input[name="mode"][value="inference"]').checked=true; computeInference(); });
    document.getElementById('add-example').addEventListener('click', ()=>{
      const val = Number(document.getElementById('new-input').value);
      if(!isNaN(val)){
        trainingData.push(val);
        renderTrainingList();
        document.getElementById('new-input').value='';
      }
    });
    document.getElementById('auto-generate').addEventListener('click', ()=>{
      trainingData = [1,3,5];
      operand = 2;
      document.getElementById('operand').value = 2;
      document.getElementById('operation').value = 'multiply';
      operation = 'multiply';
      weight = 1.0;
      renderTrainingList();
      updateMemristorVisual();
      logLine('Reset to default multiplication pattern 2×. Try training and test with 4, 7, 12.');
    });
    document.getElementsByName('mode').forEach(r=> r.addEventListener('change', e=> switchMode(e.target.value)));

    function initialize(){
      createMemristor();
      renderTrainingList();
      updateMemristorVisual();
      updateEquation(0,0);
      startIdleCurrent();
      logLine('Default training set: 1×2, 3×2, 5×2. Click Train to see ions move.');
      setTimeout(trainNetwork, 600);
    }

    initialize();
  </script>
</body>
</html>
